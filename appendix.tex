% !TeX root = main.tex

\chapter{Appendix}
\section{Einige Teile des Quellcode}
\subsection{Backend Quellcode}

\begin{lstlisting}[caption={Node/Express Backend Quelltext}, label={lst:bakcend}, language=javascript]
const express = require('express');
const bodyParser = require('body-parser');
const { parse } = require('plantuml-parser');
const cors = require('cors');
const app = express();
const port = 3000;
app.use(cors());
app.use(bodyParser.json());
app.post('/convert', (req, res) => {
  const code = req.body.code;
  try {
    const parsedCode = parse(code);
    if(parsedCode.length === 0)
       throw new Error('Failed to parse PlantUML code')

    res.json(parsedCode);
  } catch (error) {
    res.status(500)
.json({ error: 'Failed to parse PlantUML code' });
  }
});
app.listen(port, () => {
  console.log(`Server is running on port: ${port}`);
});
\end{lstlisting}


\subsection{Frontend Quellcode}
\subsubsection{Rules Definition JSON}
\begin{lstlisting}[caption={Rules Definition JSON}, label={lst:rules_def}, language=javascript]
export default {
    RULE_TYPE: {
        // CLASS & INTERFACE
        'defined_class': 'defined_class_rule',
        'defined_enum': 'defined_enum_rule',

        // GENERALIZATION & SPECIALIZATION
        'generalization': 'generalization_rule',

        // RELATIONSHIPS
        'simple_association': 'simple_association_rule',
        'composition': 'composition_rule',
        'aggregation': 'aggregation_rule',

        // ASSOCIATION CLASS
        'association_class': 'association_class_rule',

        // OPTIONAL
        'nomination_consistency': 'nomination
_consistency_rule',
        'test_association': 'test_association_rule',
        'count_methods': 'count_methods_rule',
        'count_attributes' : 'count_attributes_rule'

    },
    RULE_TYPE_JSON: {
        // CLASS & INTERFACE
        'defined_class_rule' : {
            rule_type: 'defined_class_rule',
            rule_name: 'Class definition',
            feedback: '... no feedback yet',
            points: 0,
            existence: 'presence',
            rule_specific: {
                class_name: "Car",
                abstract: false,
                interface: false,
                methods: [],
                attributes: [],
            }
        },
        // ENUM
        'defined_enum_rule' : {
            rule_type: 'defined_enum_rule',
            rule_name: 'Enum definition',
            feedback: '... no feedback',
            points: 0,
            existence: 'presence',
            rule_specific: {
                enum_class_name: "Car",
                attributes: [],
            }
        },
        // GENERALIZATION & SPECIALIZATION
        'generalization_rule' : {
            rule_type: "generalization_rule",
            rule_name: "Generalization",
            existence: "presence",
            points: 0,
            feedback: '... no feedback',
            rule_specific: {
                class_child: "Child",
                class_parent: "Parent",
                type: "inheritance" // implementation
            }
        },
        // RELATIONSHIPS
        'simple_association_rule': {
            rule_type: "simple_association_rule",
            rule_name: "Simple Association",
            existence: "presence",
            points: 0,
            feedback: "... no feedback",
            rule_specific: {
                class_A: "Class A",
                class_B: "Class B",
                A_multiplicity: "1",
                B_multiplicity: "1"
            }
        },
        'composition_rule' : {
            rule_type: "composition_rule",
            rule_name: "Composition",
            existence: "presence",
            points: 0,
            feedback: "... no feedback",
            rule_specific: {
                class_composite: "Composite",
                class_element: "Element",
                composite_multiplicity: "1",
                element_multiplicity: "*",
            }
        },
        'aggregation_rule' : {
            rule_type: "aggregation_rule",
            rule_name: "Aggregation",
            existence: "presence",
            points: 0,
            feedback: "... no feedback",
            rule_specific: {
                class_aggregate: "Aggregate",
                class_element: "Element",
                aggregate_multiplicity: "1",
                element_multiplicity: "*",
            }
        },
        // ASSOCIATION CLASS
        'association_class_rule' : {
            rule_type: "association_class_rule",
            rule_name: "Association Class",
            existence: "presence",
            points: 0,
            feedback: "Es muss eine Asso...",
            rule_specific: {
                class_A: "Class A",
                class_B: "Class B",
                class_C: "Class C"
            }
        },
        // OPTIONAL
        'nomination_consistency_rule' : {
            rule_type: "nomination_consistency_rule",
            rule_name: "Nomination Consistency",
        },
        'count_methods_rule' : {
            rule_type: "count_methods_rule",
            rule_name: "Count Methods",
            existence: 'absence',
            points: 0,
            rule_specific: {
                methods: 0,
            }
        },
        'count_attributes_rule' : {
            rule_type: "count_attributes_rule",
            rule_name: "Count Attributes",
            existence: 'absence',
            points: 0,
            rule_specific: {
                attributes: 0,
            }
        },
        'test_association_rule' : {
            rule_type: "test_association_rule",
            rule_name: "Test Association",
            existence: "absence",
            points: 0,
            rule_specific: {
                class_A: "Class A",
                class_B: "Class B",
            }
        },
    },
    METHODS_TYPE: {
        name: "public_method_name",
        return_type: "void",
        visibility: "public",
        arguments: "",
        points: 0,
        feedback: '... no feedback',
        is_static: false
    },
    ATTRIBUTE_TYPE: {
        name: "attribute_name",
        type: "string",
        visibility: "public",
        points: 0,
        feedback: '... no feedback',
        is_static: false
    },
    ENUM_ATTRIBUTE_TYPE: {
        name: "ENUM_ATTR",
        points: 0,
        feedback: '... no feedback',
    },
    EXISTENCE_TYPE: {
        'presence': 'presence',
        'absence' : 'absence'
    },
    GENERALIZATION_TYPE: {
        'inheritance': 'inheritance',
        'implementation': 'implementation'
    }
}
\end{lstlisting}

\newpage

\subsubsection{GReQL Code Generierung}
\begin{lstlisting}[caption={Fall der Class Definition Rule}, label={lst:class_def_rule}, language=javascript]
generateDefineClassRule: function (rule) {
    const isInterface = rule.rule_specific.interface
    let code = ""
    if (isInterface) {
        code += "<!-- Interface Definition -->"
        code += `<rule type="${rule.existence}"
        points="${rule.points}">
        <query>from x : V{Interface}
               with
                  isDefined(x.name) and
                  stringLevenshteinDistance(x.name,
                  "${rule.rule_specific.class_name}")&lt;3
              report 1 end
        </query>
        <feedback>${rule.feedback}</feedback>
     </rule>`
    } else {
        const isAbstract = rule.rule_specific.abstract
        let abstractCode
        if (isAbstract)
            abstractCode = `and x.isAbstract`
        else
            abstractCode = `and (not x.isAbstract)`
        code += "<!-- Class Definition -->"
        code += `<rule type="${rule.existence}"
        points="${rule.points}">
        <query>from x : V{Class}
               with
                  isDefined(x.name) and
                  stringLevenshteinDistance(x.name,
                  "${rule.rule_specific.class_name}")&lt;3
                  ${abstractCode}
               report 1 end
        </query>
        <feedback>${rule.feedback}</feedback>
    </rule>`
    }

    if(rule.rule_specific.attributes.length !== 0){
    rule.rule_specific.attributes.forEach(attribute => {
    code += this.generateAttributeRule(rule, attribute)
    })}

    if(rule.rule_specific.methods.length !== 0){
    rule.rule_specific.methods.forEach(method => {
    code += this.generateMethodRule(rule, method)
    })}

    return code
},

generateAttributeRule: function (rule, attribute) {
    /***
     1- Only 3 primitive type are working
     Integer - Boolean - String
     2- GReQL Engine cannot handle this case from BOUML XMI
     */
    let code = ""
    code += "<!-- Attribute Rule -->"

    const visibility = this.getVisibility(attribute)
    const isStatic = this.isStatic(attribute)
    const primitiveType = this.getType(attribute.type)

    let vType = "from x: V{Class}, y : V{Property}"
    let vTypeText = ""
    if (primitiveType !== '!prim') {
        vType = "from x : V{Class},
        y : V{Property},
        z : V{PrimitiveType}"
        vTypeText = `and y --> z and
        isDefined(z.name) and
        z.name="${primitiveType}"`
    }

    code += `<rule type="presence"
    points="${attribute.points}">
    <query>${vType}
           with
              isDefined(x.name) and
              stringLevenshteinDistance(x.name,
              "${rule.rule_specific.class_name}")&lt;3 and
              x --> y and isDefined(y.name) and
              stringLevenshteinDistance(y.name,
              "${attribute.name}")&lt;3 and
              ${visibility}
              ${isStatic}
              ${vTypeText}
           report 1 end
    </query>
    <feedback>${attribute.feedback}</feedback>
</rule>`
    return code
},
generateMethodRule: function (rule, method) {
    let code = ""
    const visibility = this.getVisibility(method)
    const isStatic = this.isStatic(method)
    const retType = this.getType(method.return_type)
    /***
     1- Only 3 primitive type are working
     Integer - Boolean - String
     */
    let vType = "from x: V{Class}, y : V{Operation}"
    let vTypeText = ""
    if (retType !== '!prim') {
        vType = "from x : V{Class},
        y : V{Operation},
        ret: V{Parameter},
        retType: V{PrimitiveType}"
        vTypeText = ` and y --> ret and
        isDefined(ret.name) and
        ret.name="return"  and
        ret --> retType and
        isDefined(retType.name) and
        retType.name="${retType}"`
    }

    code += "<!-- Method Rule -->"
    code += `<rule type="presence"
    points="${method.points}">
    <query>${vType}
           with
              isDefined(x.name) and
              x.name="${rule.rule_specific.class_name}" and
              isDefined(y.name) and
              stringLevenshteinDistance(y.name,
              "${method.name}")&lt;3 and
              ${visibility}
              ${isStatic} and
              x --> y
              ${vTypeText}
           report 1 end
    </query>
    <feedback>${method.feedback}</feedback>
  </rule>`

    this.extractVariableNames(method.arguments)
        .forEach( arg => {
        code += "<!-- Method Param -->"
        code += `<rule type="presence" points="0">
        <query>from x: V{Class}, y : V{Operation},
        param: V{Parameter}
        with
        isDefined(x.name) and
        stringLevenshteinDistance(x.name,
        "${rule.rule_specific.class_name}")&lt;3 and
        isDefined(y.name) and
        stringLevenshteinDistance(y.name,
        "${method.name}")&lt;3 and
        x --> y and
        y --> param and isDefined(param.name) and
        param.name="${arg}"
       report 1 end
        </query>
        <feedback>Die Methode ${method.name} muss
        ein Attribut ${arg} haben.</feedback>
      </rule>`
    })
    return code
},

extractVariableNames: function (inputString) {
    inputString += ';'
    const variablePattern = /\b(\w+)\s*,?\s*(?=[,;])/g;
    const matches = inputString.match(variablePattern);
    if (matches)
        return  matches.map(match => match.trim());
    return [];
}
getVisibility: function (accessor) {
    switch (accessor.visibility) {
        case 'public':
            return 'y.visibility="public" and '
        case 'private':
            return 'y.visibility="private" and'
        case 'protected':
            return 'y.visibility="protected" and'
        default:
            return ""
    }
},
isStatic: function (accessor) {
    if (accessor.is_static)
        return 'y.isStatic=true '
    else
        return 'y.isStatic=false '
},
getType: function (type) {
    switch (type.toLowerCase()) {
        case 'int':
            return "Integer"
        case 'string':
            return "String"
        case 'bool':
        case 'boolean':
            return "Boolean"
        default:
            return "!prim"
    }
},
\end{lstlisting}