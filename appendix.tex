% !TeX root = main.tex

\chapter{Appendix}
\section{Einige Teile des Quellcode}
\subsection{Backend Quellcode}

\begin{lstlisting}[caption={Node/Express Backend Quelltext}, label={lst:bakcend}, language=javascript]
const express = require('express');
const bodyParser = require('body-parser');
const { parse } = require('plantuml-parser');
const cors = require('cors');
const app = express();
const port = 3000;
app.use(cors());
app.use(bodyParser.json());
app.post('/convert', (req, res) => {
  const code = req.body.code;
  try {
    const parsedCode = parse(code);
    if(parsedCode.length === 0)
       throw new Error('Failed to parse PlantUML code')

    res.json(parsedCode);
  } catch (error) {
    res.status(500)
.json({ error: 'Failed to parse PlantUML code' });
  }
});
app.listen(port, () => {
  console.log(`Server is running on port: ${port}`);
});
\end{lstlisting}


\subsection{Frontend Quellcode}
\subsubsection{Rules Definition JSON}
\begin{lstlisting}[caption={Rules Definition JSON}, label={lst:rules_def}, language=javascript]
export default {
    RULE_TYPE: {
        // CLASS & INTERFACE
        'defined_class': 'defined_class_rule',
        'defined_enum': 'defined_enum_rule',

        // GENERALIZATION & SPECIALIZATION
        'generalization': 'generalization_rule',

        // RELATIONSHIPS
        'simple_association': 'simple_association_rule',
        'composition': 'composition_rule',
        'aggregation': 'aggregation_rule',

        // ASSOCIATION CLASS
        'association_class': 'association_class_rule',

        // OPTIONAL
        'nomination_consistency': 'nomination
_consistency_rule',
        'test_association': 'test_association_rule',
        'count_methods': 'count_methods_rule',

    },
    RULE_TYPE_JSON: {
        // CLASS & INTERFACE
        'defined_class_rule' : {
            rule_type: 'defined_class_rule',
            rule_name: 'Class definition',
            feedback: '... no feedback yet',
            points: 0,
            existence: 'presence',
            rule_specific: {
                class_name: "Car",
                abstract: false,
                interface: false,
                methods: [],
                attributes: [],
            }
        },
        // ENUM
        'defined_enum_rule' : {
            rule_type: 'defined_enum_rule',
            rule_name: 'Enum definition',
            feedback: '... no feedback',
            points: 0,
            existence: 'presence',
            rule_specific: {
                enum_class_name: "Car",
                attributes: [],
            }
        },
        // GENERALIZATION & SPECIALIZATION
        'generalization_rule' : {
            rule_type: "generalization_rule",
            rule_name: "Generalization",
            existence: "presence",
            points: 0,
            feedback: '... no feedback',
            rule_specific: {
                class_child: "Child",
                class_parent: "Parent",
                type: "inheritance" // implementation
            }
        },
        // RELATIONSHIPS
        'simple_association_rule': {
            rule_type: "simple_association_rule",
            rule_name: "Simple Association",
            existence: "presence",
            points: 0,
            feedback: "... no feedback",
            rule_specific: {
                class_A: "Class A",
                class_B: "Class B",
                A_multiplicity: "1",
                B_multiplicity: "1"
            }
        },
        'composition_rule' : {
            rule_type: "composition_rule",
            rule_name: "Composition",
            existence: "presence",
            points: 0,
            feedback: "... no feedback",
            rule_specific: {
                class_composite: "Composite",
                class_element: "Element",
                composite_multiplicity: "1",
                element_multiplicity: "*",
            }
        },
        'aggregation_rule' : {
            rule_type: "aggregation_rule",
            rule_name: "Aggregation",
            existence: "presence",
            points: 0,
            feedback: "... no feedback",
            rule_specific: {
                class_aggregate: "Aggregate",
                class_element: "Element",
                aggregate_multiplicity: "1",
                element_multiplicity: "*",
            }
        },
        // ASSOCIATION CLASS
        'association_class_rule' : {
            rule_type: "association_class_rule",
            rule_name: "Association Class",
            existence: "presence",
            points: 0,
            feedback: "Es muss eine Asso...",
            rule_specific: {
                class_A: "Class A",
                class_B: "Class B",
                class_C: "Class C"
            }
        },
        // OPTIONAL
        'nomination_consistency' : {
            rule_type: "nomination_consistency_rule",
            rule_name: "Nomination Consistency",
        },
        'count_methods_rule' : {
            rule_type: "count_methods_rule",
            rule_name: "Count Methods",
            existence: 'absence',
            points: 0,
            rule_specific: {
                methods: 0,
            }
        },
        'test_association_rule' : { // Done *
            rule_type: "test_association_rule",
            rule_name: "Test Association",
            existence: "absence",
            points: 0,
            rule_specific: {
                class_A: "Class A",
                class_B: "Class B",
            }
        },
    },
    METHODS_TYPE: {
        name: "public_method_name",
        return_type: "void",
        visibility: "public",
        arguments: "",
        points: 0,
        feedback: '... no feedback',
        is_static: false
    },
    ATTRIBUTE_TYPE: {
        name: "attribute_name",
        type: "string",
        visibility: "public",
        points: 0,
        feedback: '... no feedback',
        is_static: false
    },
    ENUM_ATTRIBUTE_TYPE: {
        name: "ENUM_ATTR",
        points: 0,
        feedback: '... no feedback',
    },
    EXISTENCE_TYPE: {
        'presence': 'presence',
        'absence' : 'absence'
    },
    GENERALIZATION_TYPE: {
        'inheritance': 'inheritance',
        'implementation': 'implementation'
    }
}
\end{lstlisting}